0. Please write down the full names and netids of both your team members. 
Asmaa Hasan (aah150)
Varun Ravichandran (vr250)

1. Briefly discuss how you implemented your recursive client functionality. 
We first had the client parse its command-line arguments (the RS hostname, RS port, and TS port) and saved them into separate variables. Then, we opened a socket with the root DNS server (RS) using the hostname and port provided to connect to. Lastly, we opened the PROJI-HNS.txt file and began reading through it line by line. For each query in the file, we encoded the data in UTF-8 and sent it to the root server and waited for a response. If we received a response with the A flag at the end, we promptly wrote that to the console and the RESOLVED.txt output file and continued to the next query. If we received the NS flag, we opened a socket by using that hostname and the third command-line argument (TS port) to connect to the top-level server. If the response from the TS server ended in the A flag, we took that as indication of having successfully located the entry in the DNS table and wrote that to the output file. Otherwise, the TS server sent us an ERROR:Host not found message that we transmitted to the console and the output file. This continued until the end of the HNS.txt file was reached, at which point the client sent a 'done' message to the root server so that it could shut down that connection and continue listening for more potential clients. Although the client program queries both the root-level and top-level servers in an iterative manner, the overall functionality is recursive from the eyes of a program providing hostname queries to the client program. If we imagine the file as an actual application supplying hostnames to the client program, we can easily see that the client always returns a full message back to the application. The application is never asked to query the RS or the TS directly, and rather is provided the IP address irrespective of location and an error string only if both servers have been checked. In such a manner, we were able to ensure that the client provides recursive behavior to any application connecting to it.  

3. Are there known issues or functions that aren't working currently in your attached code? If so, explain. 
We have not found any issues so far. The program compiled successfully and was able to run on different machines. We tested thoroughly by having all three programs on the same machine, client on a separate machine, the root server on a separate machine, the top-level server on a separate machine, and all three programs on completely different machines. None of these configurations appear to phase our code. We also experimented with case sensitivity by providing queries that contained a mix of upper and lower case letters when the DNS.txt files contained fully lower-cased versions of that hostname. Our implementation was able to retrieve the matching hostname without regard for case in a satisfactory manner, which seems to indicate that we've accomplished the requirements for the project.

4. What problems did you face developing code for this project?
Some parts required making decisions such as deciding on how to parse the input and get the right indexing. That involved assuming that testing would follow the same structure of querying given in the project description. In addition, deciding how to thread the program properly and developing the best way to store the IP addresses (ended up in a Python dictionary) were important aspects when developing the code.
We had some problems scaling from having the project work solely on one machine to working on multiple machines. In particular, we originally had both server programs binding manually to their localhost by using gethostbyname(gethostname). However, this resulted in some unstable behavior (connections worked sometimes, but not all the time). Based on online research, we found that it is generally good practice to simply input the empty string as the hostname that a server program is trying to bind to as it guarantees that server program will listen bind to all possible IP addresses that its localhost may take. Discovering and understanding the reason for this quirk took quite some time.

5.  What did you learn by working on this project?
 We learned how to make multiple sockets, how DNS works and the process behind requesting an IP address from the internet. Moreover, we got to experiment with how to send and receive data to and from multiple sockets in addition to exploring the nature of recursive functionality implemented in the client. The project helped provide a practical understating of DNS and more exposure to socket programming.
 The project also inadvertently taught us a bit about multithreading in Python. Although multithreading the server was not required for the project, we gave it a shot anyway as a challenge, in case the server had to scale to be able to listen to clients and handle connections simultaneously. Although we never tested the programs with multiple clients running perfectly simultaneously, it appears to have the single-client handling down and has the constructs in place to handle up to 10 clients at a time.

